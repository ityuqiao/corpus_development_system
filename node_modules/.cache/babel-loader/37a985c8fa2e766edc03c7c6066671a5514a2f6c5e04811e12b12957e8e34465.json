{"ast":null,"code":"// Token class\n\n'use strict';\n\n/**\r\n * class Token\r\n **/\n\n/**\r\n * new Token(type, tag, nesting)\r\n *\r\n * Create new token and fill passed properties.\r\n **/\nrequire(\"core-js/modules/es.array.push.js\");\nfunction Token(type, tag, nesting) {\n  /**\r\n   * Token#type -> String\r\n   *\r\n   * Type of the token (string, e.g. \"paragraph_open\")\r\n   **/\n  this.type = type;\n\n  /**\r\n   * Token#tag -> String\r\n   *\r\n   * html tag name, e.g. \"p\"\r\n   **/\n  this.tag = tag;\n\n  /**\r\n   * Token#attrs -> Array\r\n   *\r\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\r\n   **/\n  this.attrs = null;\n\n  /**\r\n   * Token#map -> Array\r\n   *\r\n   * Source map info. Format: `[ line_begin, line_end ]`\r\n   **/\n  this.map = null;\n\n  /**\r\n   * Token#nesting -> Number\r\n   *\r\n   * Level change (number in {-1, 0, 1} set), where:\r\n   *\r\n   * -  `1` means the tag is opening\r\n   * -  `0` means the tag is self-closing\r\n   * - `-1` means the tag is closing\r\n   **/\n  this.nesting = nesting;\n\n  /**\r\n   * Token#level -> Number\r\n   *\r\n   * nesting level, the same as `state.level`\r\n   **/\n  this.level = 0;\n\n  /**\r\n   * Token#children -> Array\r\n   *\r\n   * An array of child nodes (inline and img tokens)\r\n   **/\n  this.children = null;\n\n  /**\r\n   * Token#content -> String\r\n   *\r\n   * In a case of self-closing tag (code, html, fence, etc.),\r\n   * it has contents of this tag.\r\n   **/\n  this.content = '';\n\n  /**\r\n   * Token#markup -> String\r\n   *\r\n   * '*' or '_' for emphasis, fence string for fence, etc.\r\n   **/\n  this.markup = '';\n\n  /**\r\n   * Token#info -> String\r\n   *\r\n   * Additional information:\r\n   *\r\n   * - Info string for \"fence\" tokens\r\n   * - The value \"auto\" for autolink \"link_open\" and \"link_close\" tokens\r\n   * - The string value of the item marker for ordered-list \"list_item_open\" tokens\r\n   **/\n  this.info = '';\n\n  /**\r\n   * Token#meta -> Object\r\n   *\r\n   * A place for plugins to store an arbitrary data\r\n   **/\n  this.meta = null;\n\n  /**\r\n   * Token#block -> Boolean\r\n   *\r\n   * True for block-level tokens, false for inline tokens.\r\n   * Used in renderer to calculate line breaks\r\n   **/\n  this.block = false;\n\n  /**\r\n   * Token#hidden -> Boolean\r\n   *\r\n   * If it's true, ignore this element when rendering. Used for tight lists\r\n   * to hide paragraphs.\r\n   **/\n  this.hidden = false;\n}\n\n/**\r\n * Token.attrIndex(name) -> Number\r\n *\r\n * Search attribute index by name.\r\n **/\nToken.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n  if (!this.attrs) {\n    return -1;\n  }\n  attrs = this.attrs;\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\r\n * Token.attrPush(attrData)\r\n *\r\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\r\n **/\nToken.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [attrData];\n  }\n};\n\n/**\r\n * Token.attrSet(name, value)\r\n *\r\n * Set `name` attribute to `value`. Override old value if exists.\r\n **/\nToken.prototype.attrSet = function attrSet(name, value) {\n  var idx = this.attrIndex(name),\n    attrData = [name, value];\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\n\n/**\r\n * Token.attrGet(name)\r\n *\r\n * Get the value of attribute `name`, or null if it does not exist.\r\n **/\nToken.prototype.attrGet = function attrGet(name) {\n  var idx = this.attrIndex(name),\n    value = null;\n  if (idx >= 0) {\n    value = this.attrs[idx][1];\n  }\n  return value;\n};\n\n/**\r\n * Token.attrJoin(name, value)\r\n *\r\n * Join value to existing attribute via space. Or create new attribute if not\r\n * exists. Useful to operate with token classes.\r\n **/\nToken.prototype.attrJoin = function attrJoin(name, value) {\n  var idx = this.attrIndex(name);\n  if (idx < 0) {\n    this.attrPush([name, value]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n  }\n};\nmodule.exports = Token;","map":{"version":3,"names":["require","Token","type","tag","nesting","attrs","map","level","children","content","markup","info","meta","block","hidden","prototype","attrIndex","name","i","len","length","attrPush","attrData","push","attrSet","value","idx","attrGet","attrJoin","module","exports"],"sources":["C:/Users/居文韬/source/repos/corpus_development_system/node_modules/markdown-it/lib/token.js"],"sourcesContent":["// Token class\r\n\r\n'use strict';\r\n\r\n\r\n/**\r\n * class Token\r\n **/\r\n\r\n/**\r\n * new Token(type, tag, nesting)\r\n *\r\n * Create new token and fill passed properties.\r\n **/\r\nfunction Token(type, tag, nesting) {\r\n  /**\r\n   * Token#type -> String\r\n   *\r\n   * Type of the token (string, e.g. \"paragraph_open\")\r\n   **/\r\n  this.type     = type;\r\n\r\n  /**\r\n   * Token#tag -> String\r\n   *\r\n   * html tag name, e.g. \"p\"\r\n   **/\r\n  this.tag      = tag;\r\n\r\n  /**\r\n   * Token#attrs -> Array\r\n   *\r\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\r\n   **/\r\n  this.attrs    = null;\r\n\r\n  /**\r\n   * Token#map -> Array\r\n   *\r\n   * Source map info. Format: `[ line_begin, line_end ]`\r\n   **/\r\n  this.map      = null;\r\n\r\n  /**\r\n   * Token#nesting -> Number\r\n   *\r\n   * Level change (number in {-1, 0, 1} set), where:\r\n   *\r\n   * -  `1` means the tag is opening\r\n   * -  `0` means the tag is self-closing\r\n   * - `-1` means the tag is closing\r\n   **/\r\n  this.nesting  = nesting;\r\n\r\n  /**\r\n   * Token#level -> Number\r\n   *\r\n   * nesting level, the same as `state.level`\r\n   **/\r\n  this.level    = 0;\r\n\r\n  /**\r\n   * Token#children -> Array\r\n   *\r\n   * An array of child nodes (inline and img tokens)\r\n   **/\r\n  this.children = null;\r\n\r\n  /**\r\n   * Token#content -> String\r\n   *\r\n   * In a case of self-closing tag (code, html, fence, etc.),\r\n   * it has contents of this tag.\r\n   **/\r\n  this.content  = '';\r\n\r\n  /**\r\n   * Token#markup -> String\r\n   *\r\n   * '*' or '_' for emphasis, fence string for fence, etc.\r\n   **/\r\n  this.markup   = '';\r\n\r\n  /**\r\n   * Token#info -> String\r\n   *\r\n   * Additional information:\r\n   *\r\n   * - Info string for \"fence\" tokens\r\n   * - The value \"auto\" for autolink \"link_open\" and \"link_close\" tokens\r\n   * - The string value of the item marker for ordered-list \"list_item_open\" tokens\r\n   **/\r\n  this.info     = '';\r\n\r\n  /**\r\n   * Token#meta -> Object\r\n   *\r\n   * A place for plugins to store an arbitrary data\r\n   **/\r\n  this.meta     = null;\r\n\r\n  /**\r\n   * Token#block -> Boolean\r\n   *\r\n   * True for block-level tokens, false for inline tokens.\r\n   * Used in renderer to calculate line breaks\r\n   **/\r\n  this.block    = false;\r\n\r\n  /**\r\n   * Token#hidden -> Boolean\r\n   *\r\n   * If it's true, ignore this element when rendering. Used for tight lists\r\n   * to hide paragraphs.\r\n   **/\r\n  this.hidden   = false;\r\n}\r\n\r\n\r\n/**\r\n * Token.attrIndex(name) -> Number\r\n *\r\n * Search attribute index by name.\r\n **/\r\nToken.prototype.attrIndex = function attrIndex(name) {\r\n  var attrs, i, len;\r\n\r\n  if (!this.attrs) { return -1; }\r\n\r\n  attrs = this.attrs;\r\n\r\n  for (i = 0, len = attrs.length; i < len; i++) {\r\n    if (attrs[i][0] === name) { return i; }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n/**\r\n * Token.attrPush(attrData)\r\n *\r\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\r\n **/\r\nToken.prototype.attrPush = function attrPush(attrData) {\r\n  if (this.attrs) {\r\n    this.attrs.push(attrData);\r\n  } else {\r\n    this.attrs = [ attrData ];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Token.attrSet(name, value)\r\n *\r\n * Set `name` attribute to `value`. Override old value if exists.\r\n **/\r\nToken.prototype.attrSet = function attrSet(name, value) {\r\n  var idx = this.attrIndex(name),\r\n      attrData = [ name, value ];\r\n\r\n  if (idx < 0) {\r\n    this.attrPush(attrData);\r\n  } else {\r\n    this.attrs[idx] = attrData;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Token.attrGet(name)\r\n *\r\n * Get the value of attribute `name`, or null if it does not exist.\r\n **/\r\nToken.prototype.attrGet = function attrGet(name) {\r\n  var idx = this.attrIndex(name), value = null;\r\n  if (idx >= 0) {\r\n    value = this.attrs[idx][1];\r\n  }\r\n  return value;\r\n};\r\n\r\n\r\n/**\r\n * Token.attrJoin(name, value)\r\n *\r\n * Join value to existing attribute via space. Or create new attribute if not\r\n * exists. Useful to operate with token classes.\r\n **/\r\nToken.prototype.attrJoin = function attrJoin(name, value) {\r\n  var idx = this.attrIndex(name);\r\n\r\n  if (idx < 0) {\r\n    this.attrPush([ name, value ]);\r\n  } else {\r\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = Token;\r\n"],"mappings":"AAAA;;AAEA,YAAY;;AAGZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJAA,OAAA;AAKA,SAASC,KAAKA,CAACC,IAAI,EAAEC,GAAG,EAAEC,OAAO,EAAE;EACjC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACF,IAAI,GAAOA,IAAI;;EAEpB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,GAAG,GAAQA,GAAG;;EAEnB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACE,KAAK,GAAM,IAAI;;EAEpB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,GAAG,GAAQ,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACF,OAAO,GAAIA,OAAO;;EAEvB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACG,KAAK,GAAM,CAAC;;EAEjB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAI,EAAE;;EAElB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAK,EAAE;;EAElB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAO,EAAE;;EAElB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAO,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAM,KAAK;;EAErB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAK,KAAK;AACvB;;AAGA;AACA;AACA;AACA;AACA;AACAb,KAAK,CAACc,SAAS,CAACC,SAAS,GAAG,SAASA,SAASA,CAACC,IAAI,EAAE;EACnD,IAAIZ,KAAK,EAAEa,CAAC,EAAEC,GAAG;EAEjB,IAAI,CAAC,IAAI,CAACd,KAAK,EAAE;IAAE,OAAO,CAAC,CAAC;EAAE;EAE9BA,KAAK,GAAG,IAAI,CAACA,KAAK;EAElB,KAAKa,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGd,KAAK,CAACe,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC5C,IAAIb,KAAK,CAACa,CAAC,CAAC,CAAC,CAAC,CAAC,KAAKD,IAAI,EAAE;MAAE,OAAOC,CAAC;IAAE;EACxC;EACA,OAAO,CAAC,CAAC;AACX,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACAjB,KAAK,CAACc,SAAS,CAACM,QAAQ,GAAG,SAASA,QAAQA,CAACC,QAAQ,EAAE;EACrD,IAAI,IAAI,CAACjB,KAAK,EAAE;IACd,IAAI,CAACA,KAAK,CAACkB,IAAI,CAACD,QAAQ,CAAC;EAC3B,CAAC,MAAM;IACL,IAAI,CAACjB,KAAK,GAAG,CAAEiB,QAAQ,CAAE;EAC3B;AACF,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACArB,KAAK,CAACc,SAAS,CAACS,OAAO,GAAG,SAASA,OAAOA,CAACP,IAAI,EAAEQ,KAAK,EAAE;EACtD,IAAIC,GAAG,GAAG,IAAI,CAACV,SAAS,CAACC,IAAI,CAAC;IAC1BK,QAAQ,GAAG,CAAEL,IAAI,EAAEQ,KAAK,CAAE;EAE9B,IAAIC,GAAG,GAAG,CAAC,EAAE;IACX,IAAI,CAACL,QAAQ,CAACC,QAAQ,CAAC;EACzB,CAAC,MAAM;IACL,IAAI,CAACjB,KAAK,CAACqB,GAAG,CAAC,GAAGJ,QAAQ;EAC5B;AACF,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACArB,KAAK,CAACc,SAAS,CAACY,OAAO,GAAG,SAASA,OAAOA,CAACV,IAAI,EAAE;EAC/C,IAAIS,GAAG,GAAG,IAAI,CAACV,SAAS,CAACC,IAAI,CAAC;IAAEQ,KAAK,GAAG,IAAI;EAC5C,IAAIC,GAAG,IAAI,CAAC,EAAE;IACZD,KAAK,GAAG,IAAI,CAACpB,KAAK,CAACqB,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5B;EACA,OAAOD,KAAK;AACd,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACAxB,KAAK,CAACc,SAAS,CAACa,QAAQ,GAAG,SAASA,QAAQA,CAACX,IAAI,EAAEQ,KAAK,EAAE;EACxD,IAAIC,GAAG,GAAG,IAAI,CAACV,SAAS,CAACC,IAAI,CAAC;EAE9B,IAAIS,GAAG,GAAG,CAAC,EAAE;IACX,IAAI,CAACL,QAAQ,CAAC,CAAEJ,IAAI,EAAEQ,KAAK,CAAE,CAAC;EAChC,CAAC,MAAM;IACL,IAAI,CAACpB,KAAK,CAACqB,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACqB,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGD,KAAK;EACvD;AACF,CAAC;AAGDI,MAAM,CAACC,OAAO,GAAG7B,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}