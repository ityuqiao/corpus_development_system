{"ast":null,"code":"/**\r\n * class Ruler\r\n *\r\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\r\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\r\n *\r\n * - keep rules in defined order\r\n * - assign the name to each rule\r\n * - enable/disable rules\r\n * - add/replace rules\r\n * - allow assign rules to additional named chains (in the same)\r\n * - cacheing lists of active rules\r\n *\r\n * You will not need use this class directly until write plugins. For simple\r\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\r\n * [[MarkdownIt.use]].\r\n **/\n'use strict';\n\n/**\r\n * new Ruler()\r\n **/\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.at.js\");\nrequire(\"core-js/modules/es.string.at-alternative.js\");\nrequire(\"core-js/modules/es.error.cause.js\");\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [''];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n  self.__cache__ = {};\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n/**\r\n * Ruler.at(name, fn [, options])\r\n * - name (String): rule name to replace.\r\n * - fn (Function): new rule function.\r\n * - options (Object): new rule options (not mandatory).\r\n *\r\n * Replace rule by name with new function & options. Throws error if name not\r\n * found.\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * Replace existing typographer replacement rule with new one:\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.core.ruler.at('replacements', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n  if (index === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n/**\r\n * Ruler.before(beforeName, ruleName, fn [, options])\r\n * - beforeName (String): new rule will be added before this one.\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Add new rule to chain before one with given name. See also\r\n * [[Ruler.after]], [[Ruler.push]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n  if (index === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n  this.__cache__ = null;\n};\n\n/**\r\n * Ruler.after(afterName, ruleName, fn [, options])\r\n * - afterName (String): new rule will be added after this one.\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Add new rule to chain after one with given name. See also\r\n * [[Ruler.before]], [[Ruler.push]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n  if (index === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n  this.__cache__ = null;\n};\n\n/**\r\n * Ruler.push(ruleName, fn [, options])\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Push new rule to the end of chain. See also\r\n * [[Ruler.before]], [[Ruler.after]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.core.ruler.push('my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n  this.__cache__ = null;\n};\n\n/**\r\n * Ruler.enable(list [, ignoreInvalid]) -> Array\r\n * - list (String|Array): list of rule names to enable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable rules with given names. If any rule name not found - throw Error.\r\n * Errors can be disabled by second param.\r\n *\r\n * Returns list of found rule names (if no exception happened).\r\n *\r\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\r\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) {\n    list = [list];\n  }\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      if (ignoreInvalid) {\n        return;\n      }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n  this.__cache__ = null;\n  return result;\n};\n\n/**\r\n * Ruler.enableOnly(list [, ignoreInvalid])\r\n * - list (String|Array): list of rule names to enable (whitelist).\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable rules with given names, and disable everything else. If any rule name\r\n * not found - throw Error. Errors can be disabled by second param.\r\n *\r\n * See also [[Ruler.disable]], [[Ruler.enable]].\r\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) {\n    list = [list];\n  }\n  this.__rules__.forEach(function (rule) {\n    rule.enabled = false;\n  });\n  this.enable(list, ignoreInvalid);\n};\n\n/**\r\n * Ruler.disable(list [, ignoreInvalid]) -> Array\r\n * - list (String|Array): list of rule names to disable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Disable rules with given names. If any rule name not found - throw Error.\r\n * Errors can be disabled by second param.\r\n *\r\n * Returns list of found rule names (if no exception happened).\r\n *\r\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\r\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) {\n    list = [list];\n  }\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      if (ignoreInvalid) {\n        return;\n      }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n  this.__cache__ = null;\n  return result;\n};\n\n/**\r\n * Ruler.getRules(chainName) -> Array\r\n *\r\n * Return array of active functions (rules) for given chain name. It analyzes\r\n * rules configuration, compiles caches if not exists and returns result.\r\n *\r\n * Default chain name is `''` (empty string). It can't be skipped. That's\r\n * done intentionally, to keep signature monomorphic for high speed.\r\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\nmodule.exports = Ruler;","map":{"version":3,"names":["require","Ruler","__rules__","__cache__","prototype","__find__","name","i","length","__compile__","self","chains","forEach","rule","enabled","alt","altName","indexOf","push","chain","fn","at","options","index","opt","Error","before","beforeName","ruleName","splice","after","afterName","enable","list","ignoreInvalid","Array","isArray","result","idx","enableOnly","disable","getRules","chainName","module","exports"],"sources":["C:/Users/居文韬/source/repos/corpus_development_system/node_modules/markdown-it/lib/ruler.js"],"sourcesContent":["/**\r\n * class Ruler\r\n *\r\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\r\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\r\n *\r\n * - keep rules in defined order\r\n * - assign the name to each rule\r\n * - enable/disable rules\r\n * - add/replace rules\r\n * - allow assign rules to additional named chains (in the same)\r\n * - cacheing lists of active rules\r\n *\r\n * You will not need use this class directly until write plugins. For simple\r\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\r\n * [[MarkdownIt.use]].\r\n **/\r\n'use strict';\r\n\r\n\r\n/**\r\n * new Ruler()\r\n **/\r\nfunction Ruler() {\r\n  // List of added rules. Each element is:\r\n  //\r\n  // {\r\n  //   name: XXX,\r\n  //   enabled: Boolean,\r\n  //   fn: Function(),\r\n  //   alt: [ name2, name3 ]\r\n  // }\r\n  //\r\n  this.__rules__ = [];\r\n\r\n  // Cached rule chains.\r\n  //\r\n  // First level - chain name, '' for default.\r\n  // Second level - diginal anchor for fast filtering by charcodes.\r\n  //\r\n  this.__cache__ = null;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Helper methods, should not be used directly\r\n\r\n\r\n// Find rule index by name\r\n//\r\nRuler.prototype.__find__ = function (name) {\r\n  for (var i = 0; i < this.__rules__.length; i++) {\r\n    if (this.__rules__[i].name === name) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n// Build rules lookup cache\r\n//\r\nRuler.prototype.__compile__ = function () {\r\n  var self = this;\r\n  var chains = [ '' ];\r\n\r\n  // collect unique names\r\n  self.__rules__.forEach(function (rule) {\r\n    if (!rule.enabled) { return; }\r\n\r\n    rule.alt.forEach(function (altName) {\r\n      if (chains.indexOf(altName) < 0) {\r\n        chains.push(altName);\r\n      }\r\n    });\r\n  });\r\n\r\n  self.__cache__ = {};\r\n\r\n  chains.forEach(function (chain) {\r\n    self.__cache__[chain] = [];\r\n    self.__rules__.forEach(function (rule) {\r\n      if (!rule.enabled) { return; }\r\n\r\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\r\n\r\n      self.__cache__[chain].push(rule.fn);\r\n    });\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Ruler.at(name, fn [, options])\r\n * - name (String): rule name to replace.\r\n * - fn (Function): new rule function.\r\n * - options (Object): new rule options (not mandatory).\r\n *\r\n * Replace rule by name with new function & options. Throws error if name not\r\n * found.\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * Replace existing typographer replacement rule with new one:\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.core.ruler.at('replacements', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.at = function (name, fn, options) {\r\n  var index = this.__find__(name);\r\n  var opt = options || {};\r\n\r\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\r\n\r\n  this.__rules__[index].fn = fn;\r\n  this.__rules__[index].alt = opt.alt || [];\r\n  this.__cache__ = null;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.before(beforeName, ruleName, fn [, options])\r\n * - beforeName (String): new rule will be added before this one.\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Add new rule to chain before one with given name. See also\r\n * [[Ruler.after]], [[Ruler.push]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\r\n  var index = this.__find__(beforeName);\r\n  var opt = options || {};\r\n\r\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\r\n\r\n  this.__rules__.splice(index, 0, {\r\n    name: ruleName,\r\n    enabled: true,\r\n    fn: fn,\r\n    alt: opt.alt || []\r\n  });\r\n\r\n  this.__cache__ = null;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.after(afterName, ruleName, fn [, options])\r\n * - afterName (String): new rule will be added after this one.\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Add new rule to chain after one with given name. See also\r\n * [[Ruler.before]], [[Ruler.push]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\r\n  var index = this.__find__(afterName);\r\n  var opt = options || {};\r\n\r\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\r\n\r\n  this.__rules__.splice(index + 1, 0, {\r\n    name: ruleName,\r\n    enabled: true,\r\n    fn: fn,\r\n    alt: opt.alt || []\r\n  });\r\n\r\n  this.__cache__ = null;\r\n};\r\n\r\n/**\r\n * Ruler.push(ruleName, fn [, options])\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Push new rule to the end of chain. See also\r\n * [[Ruler.before]], [[Ruler.after]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.core.ruler.push('my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.push = function (ruleName, fn, options) {\r\n  var opt = options || {};\r\n\r\n  this.__rules__.push({\r\n    name: ruleName,\r\n    enabled: true,\r\n    fn: fn,\r\n    alt: opt.alt || []\r\n  });\r\n\r\n  this.__cache__ = null;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.enable(list [, ignoreInvalid]) -> Array\r\n * - list (String|Array): list of rule names to enable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable rules with given names. If any rule name not found - throw Error.\r\n * Errors can be disabled by second param.\r\n *\r\n * Returns list of found rule names (if no exception happened).\r\n *\r\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\r\n **/\r\nRuler.prototype.enable = function (list, ignoreInvalid) {\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  var result = [];\r\n\r\n  // Search by name and enable\r\n  list.forEach(function (name) {\r\n    var idx = this.__find__(name);\r\n\r\n    if (idx < 0) {\r\n      if (ignoreInvalid) { return; }\r\n      throw new Error('Rules manager: invalid rule name ' + name);\r\n    }\r\n    this.__rules__[idx].enabled = true;\r\n    result.push(name);\r\n  }, this);\r\n\r\n  this.__cache__ = null;\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.enableOnly(list [, ignoreInvalid])\r\n * - list (String|Array): list of rule names to enable (whitelist).\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable rules with given names, and disable everything else. If any rule name\r\n * not found - throw Error. Errors can be disabled by second param.\r\n *\r\n * See also [[Ruler.disable]], [[Ruler.enable]].\r\n **/\r\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\r\n\r\n  this.enable(list, ignoreInvalid);\r\n};\r\n\r\n\r\n/**\r\n * Ruler.disable(list [, ignoreInvalid]) -> Array\r\n * - list (String|Array): list of rule names to disable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Disable rules with given names. If any rule name not found - throw Error.\r\n * Errors can be disabled by second param.\r\n *\r\n * Returns list of found rule names (if no exception happened).\r\n *\r\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\r\n **/\r\nRuler.prototype.disable = function (list, ignoreInvalid) {\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  var result = [];\r\n\r\n  // Search by name and disable\r\n  list.forEach(function (name) {\r\n    var idx = this.__find__(name);\r\n\r\n    if (idx < 0) {\r\n      if (ignoreInvalid) { return; }\r\n      throw new Error('Rules manager: invalid rule name ' + name);\r\n    }\r\n    this.__rules__[idx].enabled = false;\r\n    result.push(name);\r\n  }, this);\r\n\r\n  this.__cache__ = null;\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.getRules(chainName) -> Array\r\n *\r\n * Return array of active functions (rules) for given chain name. It analyzes\r\n * rules configuration, compiles caches if not exists and returns result.\r\n *\r\n * Default chain name is `''` (empty string). It can't be skipped. That's\r\n * done intentionally, to keep signature monomorphic for high speed.\r\n **/\r\nRuler.prototype.getRules = function (chainName) {\r\n  if (this.__cache__ === null) {\r\n    this.__compile__();\r\n  }\r\n\r\n  // Chain can be empty, if rules disabled. But we still have to return Array.\r\n  return this.__cache__[chainName] || [];\r\n};\r\n\r\nmodule.exports = Ruler;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}