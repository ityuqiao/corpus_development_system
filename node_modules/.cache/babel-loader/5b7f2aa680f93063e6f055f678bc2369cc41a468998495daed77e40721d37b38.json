{"ast":null,"code":"// Lists\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar isSpace = require('../common/utils').isSpace;\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {\n    return -1;\n  }\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n    start = state.bMarks[startLine] + state.tShift[startLine],\n    pos = start,\n    max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) {\n    return -1;\n  }\n  ch = state.src.charCodeAt(pos++);\n  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {\n    return -1;\n  }\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n    ch = state.src.charCodeAt(pos++);\n    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) {\n        return -1;\n      }\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {\n      break;\n    }\n    return -1;\n  }\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\nfunction markTightParagraphs(state, idx) {\n  var i,\n    l,\n    level = state.level + 2;\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n    contentStart,\n    i,\n    indent,\n    indentAfterMarker,\n    initial,\n    isOrdered,\n    itemLines,\n    l,\n    listLines,\n    listTokIdx,\n    markerCharCode,\n    markerValue,\n    max,\n    nextLine,\n    offset,\n    oldListIndent,\n    oldParentType,\n    oldSCount,\n    oldTShift,\n    oldTight,\n    pos,\n    posAfterMarker,\n    prevEmptyEnd,\n    start,\n    terminate,\n    terminatorRules,\n    token,\n    isTerminatingParagraph = false,\n    tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) {\n    return true;\n  }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n  if (isOrdered) {\n    token = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]];\n    }\n  } else {\n    token = state.push('bullet_list_open', 'ul', 1);\n  }\n  token.map = listLines = [startLine, 0];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n      pos++;\n    }\n    contentStart = pos;\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map = itemLines = [startLine, 0];\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1);\n    }\n\n    // change current state, then restore it after parser subcall\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n    token = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n      break;\n    }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n  listLines[1] = nextLine;\n  state.line = nextLine;\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n  return true;\n};","map":{"version":3,"names":["require","isSpace","skipBulletListMarker","state","startLine","marker","pos","max","ch","bMarks","tShift","eMarks","src","charCodeAt","skipOrderedListMarker","start","markTightParagraphs","idx","i","l","level","tokens","length","type","hidden","module","exports","list","endLine","silent","contentStart","indent","indentAfterMarker","initial","isOrdered","itemLines","listLines","listTokIdx","markerCharCode","markerValue","nextLine","offset","oldListIndent","oldParentType","oldSCount","oldTShift","oldTight","posAfterMarker","prevEmptyEnd","terminate","terminatorRules","token","isTerminatingParagraph","tight","sCount","blkIndent","listIndent","parentType","Number","slice","skipSpaces","push","attrs","map","markup","String","fromCharCode","md","block","ruler","getRules","bsCount","info","isEmpty","line","Math","min","tokenize"],"sources":["C:/Users/居文韬/source/repos/corpus_development_system/node_modules/markdown-it/lib/rules_block/list.js"],"sourcesContent":["// Lists\r\n\r\n'use strict';\r\n\r\nvar isSpace = require('../common/utils').isSpace;\r\n\r\n\r\n// Search `[-+*][\\n ]`, returns next pos after marker on success\r\n// or -1 on fail.\r\nfunction skipBulletListMarker(state, startLine) {\r\n  var marker, pos, max, ch;\r\n\r\n  pos = state.bMarks[startLine] + state.tShift[startLine];\r\n  max = state.eMarks[startLine];\r\n\r\n  marker = state.src.charCodeAt(pos++);\r\n  // Check bullet\r\n  if (marker !== 0x2A/* * */ &&\r\n      marker !== 0x2D/* - */ &&\r\n      marker !== 0x2B/* + */) {\r\n    return -1;\r\n  }\r\n\r\n  if (pos < max) {\r\n    ch = state.src.charCodeAt(pos);\r\n\r\n    if (!isSpace(ch)) {\r\n      // \" -test \" - is not a list item\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  return pos;\r\n}\r\n\r\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\r\n// or -1 on fail.\r\nfunction skipOrderedListMarker(state, startLine) {\r\n  var ch,\r\n      start = state.bMarks[startLine] + state.tShift[startLine],\r\n      pos = start,\r\n      max = state.eMarks[startLine];\r\n\r\n  // List marker should have at least 2 chars (digit + dot)\r\n  if (pos + 1 >= max) { return -1; }\r\n\r\n  ch = state.src.charCodeAt(pos++);\r\n\r\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\r\n\r\n  for (;;) {\r\n    // EOL -> fail\r\n    if (pos >= max) { return -1; }\r\n\r\n    ch = state.src.charCodeAt(pos++);\r\n\r\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\r\n\r\n      // List marker should have no more than 9 digits\r\n      // (prevents integer overflow in browsers)\r\n      if (pos - start >= 10) { return -1; }\r\n\r\n      continue;\r\n    }\r\n\r\n    // found valid marker\r\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\r\n      break;\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n\r\n  if (pos < max) {\r\n    ch = state.src.charCodeAt(pos);\r\n\r\n    if (!isSpace(ch)) {\r\n      // \" 1.test \" - is not a list item\r\n      return -1;\r\n    }\r\n  }\r\n  return pos;\r\n}\r\n\r\nfunction markTightParagraphs(state, idx) {\r\n  var i, l,\r\n      level = state.level + 2;\r\n\r\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\r\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\r\n      state.tokens[i + 2].hidden = true;\r\n      state.tokens[i].hidden = true;\r\n      i += 2;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = function list(state, startLine, endLine, silent) {\r\n  var ch,\r\n      contentStart,\r\n      i,\r\n      indent,\r\n      indentAfterMarker,\r\n      initial,\r\n      isOrdered,\r\n      itemLines,\r\n      l,\r\n      listLines,\r\n      listTokIdx,\r\n      markerCharCode,\r\n      markerValue,\r\n      max,\r\n      nextLine,\r\n      offset,\r\n      oldListIndent,\r\n      oldParentType,\r\n      oldSCount,\r\n      oldTShift,\r\n      oldTight,\r\n      pos,\r\n      posAfterMarker,\r\n      prevEmptyEnd,\r\n      start,\r\n      terminate,\r\n      terminatorRules,\r\n      token,\r\n      isTerminatingParagraph = false,\r\n      tight = true;\r\n\r\n  // if it's indented more than 3 spaces, it should be a code block\r\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\r\n\r\n  // Special case:\r\n  //  - item 1\r\n  //   - item 2\r\n  //    - item 3\r\n  //     - item 4\r\n  //      - this one is a paragraph continuation\r\n  if (state.listIndent >= 0 &&\r\n      state.sCount[startLine] - state.listIndent >= 4 &&\r\n      state.sCount[startLine] < state.blkIndent) {\r\n    return false;\r\n  }\r\n\r\n  // limit conditions when list can interrupt\r\n  // a paragraph (validation mode only)\r\n  if (silent && state.parentType === 'paragraph') {\r\n    // Next list item should still terminate previous list item;\r\n    //\r\n    // This code can fail if plugins use blkIndent as well as lists,\r\n    // but I hope the spec gets fixed long before that happens.\r\n    //\r\n    if (state.sCount[startLine] >= state.blkIndent) {\r\n      isTerminatingParagraph = true;\r\n    }\r\n  }\r\n\r\n  // Detect list type and position after marker\r\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\r\n    isOrdered = true;\r\n    start = state.bMarks[startLine] + state.tShift[startLine];\r\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1));\r\n\r\n    // If we're starting a new ordered list right after\r\n    // a paragraph, it should start with 1.\r\n    if (isTerminatingParagraph && markerValue !== 1) return false;\r\n\r\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\r\n    isOrdered = false;\r\n\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  // If we're starting a new unordered list right after\r\n  // a paragraph, first line should not be empty.\r\n  if (isTerminatingParagraph) {\r\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\r\n  }\r\n\r\n  // We should terminate list on style change. Remember first one to compare.\r\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\r\n\r\n  // For validation mode we can terminate immediately\r\n  if (silent) { return true; }\r\n\r\n  // Start list\r\n  listTokIdx = state.tokens.length;\r\n\r\n  if (isOrdered) {\r\n    token       = state.push('ordered_list_open', 'ol', 1);\r\n    if (markerValue !== 1) {\r\n      token.attrs = [ [ 'start', markerValue ] ];\r\n    }\r\n\r\n  } else {\r\n    token       = state.push('bullet_list_open', 'ul', 1);\r\n  }\r\n\r\n  token.map    = listLines = [ startLine, 0 ];\r\n  token.markup = String.fromCharCode(markerCharCode);\r\n\r\n  //\r\n  // Iterate list items\r\n  //\r\n\r\n  nextLine = startLine;\r\n  prevEmptyEnd = false;\r\n  terminatorRules = state.md.block.ruler.getRules('list');\r\n\r\n  oldParentType = state.parentType;\r\n  state.parentType = 'list';\r\n\r\n  while (nextLine < endLine) {\r\n    pos = posAfterMarker;\r\n    max = state.eMarks[nextLine];\r\n\r\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\r\n\r\n    while (pos < max) {\r\n      ch = state.src.charCodeAt(pos);\r\n\r\n      if (ch === 0x09) {\r\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\r\n      } else if (ch === 0x20) {\r\n        offset++;\r\n      } else {\r\n        break;\r\n      }\r\n\r\n      pos++;\r\n    }\r\n\r\n    contentStart = pos;\r\n\r\n    if (contentStart >= max) {\r\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\r\n      indentAfterMarker = 1;\r\n    } else {\r\n      indentAfterMarker = offset - initial;\r\n    }\r\n\r\n    // If we have more than 4 spaces, the indent is 1\r\n    // (the rest is just indented code block)\r\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\r\n\r\n    // \"  -  test\"\r\n    //  ^^^^^ - calculating total length of this thing\r\n    indent = initial + indentAfterMarker;\r\n\r\n    // Run subparser & write tokens\r\n    token        = state.push('list_item_open', 'li', 1);\r\n    token.markup = String.fromCharCode(markerCharCode);\r\n    token.map    = itemLines = [ startLine, 0 ];\r\n    if (isOrdered) {\r\n      token.info = state.src.slice(start, posAfterMarker - 1);\r\n    }\r\n\r\n    // change current state, then restore it after parser subcall\r\n    oldTight = state.tight;\r\n    oldTShift = state.tShift[startLine];\r\n    oldSCount = state.sCount[startLine];\r\n\r\n    //  - example list\r\n    // ^ listIndent position will be here\r\n    //   ^ blkIndent position will be here\r\n    //\r\n    oldListIndent = state.listIndent;\r\n    state.listIndent = state.blkIndent;\r\n    state.blkIndent = indent;\r\n\r\n    state.tight = true;\r\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\r\n    state.sCount[startLine] = offset;\r\n\r\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\r\n      // workaround for this case\r\n      // (list item is empty, list terminates before \"foo\"):\r\n      // ~~~~~~~~\r\n      //   -\r\n      //\r\n      //     foo\r\n      // ~~~~~~~~\r\n      state.line = Math.min(state.line + 2, endLine);\r\n    } else {\r\n      state.md.block.tokenize(state, startLine, endLine, true);\r\n    }\r\n\r\n    // If any of list item is tight, mark list as tight\r\n    if (!state.tight || prevEmptyEnd) {\r\n      tight = false;\r\n    }\r\n    // Item become loose if finish with empty line,\r\n    // but we should filter last element, because it means list finish\r\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\r\n\r\n    state.blkIndent = state.listIndent;\r\n    state.listIndent = oldListIndent;\r\n    state.tShift[startLine] = oldTShift;\r\n    state.sCount[startLine] = oldSCount;\r\n    state.tight = oldTight;\r\n\r\n    token        = state.push('list_item_close', 'li', -1);\r\n    token.markup = String.fromCharCode(markerCharCode);\r\n\r\n    nextLine = startLine = state.line;\r\n    itemLines[1] = nextLine;\r\n    contentStart = state.bMarks[startLine];\r\n\r\n    if (nextLine >= endLine) { break; }\r\n\r\n    //\r\n    // Try to check if list is terminated or continued.\r\n    //\r\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\r\n\r\n    // if it's indented more than 3 spaces, it should be a code block\r\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\r\n\r\n    // fail if terminating block found\r\n    terminate = false;\r\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n        terminate = true;\r\n        break;\r\n      }\r\n    }\r\n    if (terminate) { break; }\r\n\r\n    // fail if list has another type\r\n    if (isOrdered) {\r\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\r\n      if (posAfterMarker < 0) { break; }\r\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\r\n    } else {\r\n      posAfterMarker = skipBulletListMarker(state, nextLine);\r\n      if (posAfterMarker < 0) { break; }\r\n    }\r\n\r\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\r\n  }\r\n\r\n  // Finalize list\r\n  if (isOrdered) {\r\n    token = state.push('ordered_list_close', 'ol', -1);\r\n  } else {\r\n    token = state.push('bullet_list_close', 'ul', -1);\r\n  }\r\n  token.markup = String.fromCharCode(markerCharCode);\r\n\r\n  listLines[1] = nextLine;\r\n  state.line = nextLine;\r\n\r\n  state.parentType = oldParentType;\r\n\r\n  // mark paragraphs tight if needed\r\n  if (tight) {\r\n    markTightParagraphs(state, listTokIdx);\r\n  }\r\n\r\n  return true;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}