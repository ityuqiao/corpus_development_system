{"ast":null,"code":"/** internal\r\n * class ParserInline\r\n *\r\n * Tokenizes paragraph content.\r\n **/\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar Ruler = require('./ruler');\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [['text', require('./rules_inline/text')], ['linkify', require('./rules_inline/linkify')], ['newline', require('./rules_inline/newline')], ['escape', require('./rules_inline/escape')], ['backticks', require('./rules_inline/backticks')], ['strikethrough', require('./rules_inline/strikethrough').tokenize], ['emphasis', require('./rules_inline/emphasis').tokenize], ['link', require('./rules_inline/link')], ['image', require('./rules_inline/image')], ['autolink', require('./rules_inline/autolink')], ['html_inline', require('./rules_inline/html_inline')], ['entity', require('./rules_inline/entity')]];\n\n// `rule2` ruleset was created specifically for emphasis/strikethrough\n// post-processing and may be changed in the future.\n//\n// Don't use this for anything except pairs (plugins working with `balance_pairs`).\n//\nvar _rules2 = [['balance_pairs', require('./rules_inline/balance_pairs')], ['strikethrough', require('./rules_inline/strikethrough').postProcess], ['emphasis', require('./rules_inline/emphasis').postProcess],\n// rules for pairs separate '**' into its own text tokens, which may be left unused,\n// rule below merges unused segments back with the rest of the text\n['fragments_join', require('./rules_inline/fragments_join')]];\n\n/**\r\n * new ParserInline()\r\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\r\n   * ParserInline#ruler -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Keep configuration of inline rules.\r\n   **/\n  this.ruler = new Ruler();\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\r\n   * ParserInline#ruler2 -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Second ruler used for post-processing\r\n   * (e.g. in emphasis-like rules).\r\n   **/\n  this.ruler2 = new Ruler();\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok,\n    i,\n    pos = state.pos,\n    rules = this.ruler.getRules(''),\n    len = rules.length,\n    maxNesting = state.md.options.maxNesting,\n    cache = state.cache;\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n      if (ok) {\n        break;\n      }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n  if (!ok) {\n    state.pos++;\n  }\n  cache[pos] = state.pos;\n};\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok,\n    i,\n    rules = this.ruler.getRules(''),\n    len = rules.length,\n    end = state.posMax,\n    maxNesting = state.md.options.maxNesting;\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) {\n          break;\n        }\n      }\n    }\n    if (ok) {\n      if (state.pos >= end) {\n        break;\n      }\n      continue;\n    }\n    state.pending += state.src[state.pos++];\n  }\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n/**\r\n * ParserInline.parse(str, md, env, outTokens)\r\n *\r\n * Process input string and push inline tokens into `outTokens`\r\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n  this.tokenize(state);\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\nParserInline.prototype.State = require('./rules_inline/state_inline');\nmodule.exports = ParserInline;","map":{"version":3,"names":["require","Ruler","_rules","tokenize","_rules2","postProcess","ParserInline","i","ruler","length","push","ruler2","prototype","skipToken","state","ok","pos","rules","getRules","len","maxNesting","md","options","cache","level","posMax","end","pending","src","pushPending","parse","str","env","outTokens","State","module","exports"],"sources":["C:/Users/居文韬/source/repos/corpus_development_system/node_modules/markdown-it/lib/parser_inline.js"],"sourcesContent":["/** internal\r\n * class ParserInline\r\n *\r\n * Tokenizes paragraph content.\r\n **/\r\n'use strict';\r\n\r\n\r\nvar Ruler           = require('./ruler');\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Parser rules\r\n\r\nvar _rules = [\r\n  [ 'text',            require('./rules_inline/text') ],\r\n  [ 'linkify',         require('./rules_inline/linkify') ],\r\n  [ 'newline',         require('./rules_inline/newline') ],\r\n  [ 'escape',          require('./rules_inline/escape') ],\r\n  [ 'backticks',       require('./rules_inline/backticks') ],\r\n  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],\r\n  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],\r\n  [ 'link',            require('./rules_inline/link') ],\r\n  [ 'image',           require('./rules_inline/image') ],\r\n  [ 'autolink',        require('./rules_inline/autolink') ],\r\n  [ 'html_inline',     require('./rules_inline/html_inline') ],\r\n  [ 'entity',          require('./rules_inline/entity') ]\r\n];\r\n\r\n// `rule2` ruleset was created specifically for emphasis/strikethrough\r\n// post-processing and may be changed in the future.\r\n//\r\n// Don't use this for anything except pairs (plugins working with `balance_pairs`).\r\n//\r\nvar _rules2 = [\r\n  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],\r\n  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],\r\n  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],\r\n  // rules for pairs separate '**' into its own text tokens, which may be left unused,\r\n  // rule below merges unused segments back with the rest of the text\r\n  [ 'fragments_join',  require('./rules_inline/fragments_join') ]\r\n];\r\n\r\n\r\n/**\r\n * new ParserInline()\r\n **/\r\nfunction ParserInline() {\r\n  var i;\r\n\r\n  /**\r\n   * ParserInline#ruler -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Keep configuration of inline rules.\r\n   **/\r\n  this.ruler = new Ruler();\r\n\r\n  for (i = 0; i < _rules.length; i++) {\r\n    this.ruler.push(_rules[i][0], _rules[i][1]);\r\n  }\r\n\r\n  /**\r\n   * ParserInline#ruler2 -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Second ruler used for post-processing\r\n   * (e.g. in emphasis-like rules).\r\n   **/\r\n  this.ruler2 = new Ruler();\r\n\r\n  for (i = 0; i < _rules2.length; i++) {\r\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\r\n  }\r\n}\r\n\r\n\r\n// Skip single token by running all rules in validation mode;\r\n// returns `true` if any rule reported success\r\n//\r\nParserInline.prototype.skipToken = function (state) {\r\n  var ok, i, pos = state.pos,\r\n      rules = this.ruler.getRules(''),\r\n      len = rules.length,\r\n      maxNesting = state.md.options.maxNesting,\r\n      cache = state.cache;\r\n\r\n\r\n  if (typeof cache[pos] !== 'undefined') {\r\n    state.pos = cache[pos];\r\n    return;\r\n  }\r\n\r\n  if (state.level < maxNesting) {\r\n    for (i = 0; i < len; i++) {\r\n      // Increment state.level and decrement it later to limit recursion.\r\n      // It's harmless to do here, because no tokens are created. But ideally,\r\n      // we'd need a separate private state variable for this purpose.\r\n      //\r\n      state.level++;\r\n      ok = rules[i](state, true);\r\n      state.level--;\r\n\r\n      if (ok) { break; }\r\n    }\r\n  } else {\r\n    // Too much nesting, just skip until the end of the paragraph.\r\n    //\r\n    // NOTE: this will cause links to behave incorrectly in the following case,\r\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\r\n    //\r\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\r\n    //\r\n    // TODO: remove this workaround when CM standard will allow nested links\r\n    //       (we can replace it by preventing links from being parsed in\r\n    //       validation mode)\r\n    //\r\n    state.pos = state.posMax;\r\n  }\r\n\r\n  if (!ok) { state.pos++; }\r\n  cache[pos] = state.pos;\r\n};\r\n\r\n\r\n// Generate tokens for input range\r\n//\r\nParserInline.prototype.tokenize = function (state) {\r\n  var ok, i,\r\n      rules = this.ruler.getRules(''),\r\n      len = rules.length,\r\n      end = state.posMax,\r\n      maxNesting = state.md.options.maxNesting;\r\n\r\n  while (state.pos < end) {\r\n    // Try all possible rules.\r\n    // On success, rule should:\r\n    //\r\n    // - update `state.pos`\r\n    // - update `state.tokens`\r\n    // - return true\r\n\r\n    if (state.level < maxNesting) {\r\n      for (i = 0; i < len; i++) {\r\n        ok = rules[i](state, false);\r\n        if (ok) { break; }\r\n      }\r\n    }\r\n\r\n    if (ok) {\r\n      if (state.pos >= end) { break; }\r\n      continue;\r\n    }\r\n\r\n    state.pending += state.src[state.pos++];\r\n  }\r\n\r\n  if (state.pending) {\r\n    state.pushPending();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * ParserInline.parse(str, md, env, outTokens)\r\n *\r\n * Process input string and push inline tokens into `outTokens`\r\n **/\r\nParserInline.prototype.parse = function (str, md, env, outTokens) {\r\n  var i, rules, len;\r\n  var state = new this.State(str, md, env, outTokens);\r\n\r\n  this.tokenize(state);\r\n\r\n  rules = this.ruler2.getRules('');\r\n  len = rules.length;\r\n\r\n  for (i = 0; i < len; i++) {\r\n    rules[i](state);\r\n  }\r\n};\r\n\r\n\r\nParserInline.prototype.State = require('./rules_inline/state_inline');\r\n\r\n\r\nmodule.exports = ParserInline;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}